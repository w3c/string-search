<!DOCTYPE html>
<html dir="ltr" lang="en">
  <head>
    <meta charset="UTF-8">
    <title>String Searching</title>

    <!-- local styles. Includes the styles from http://www.w3.org/International/docs/styleguide -->
    <link rel="stylesheet" href="local.css" type="text/css">
    
	<script src="https://www.w3.org/Tools/respec/respec-w3c" async class="remove"></script>
    <script class="remove">
      var respecConfig = {
          useExperimentalStyles: true,
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:				"ED",
          //publishDate:  			"2020-03-20",
          //previousMaturity:  		"ED",

          noRecTrack:           true,
          shortName:            "string-search",
          copyrightStart: 		"2016",
          edDraftURI:   		"https://w3c.github.io/string-search/",
          group:                "i18n",
          github:               "w3c/string-search",
          xref:                 ["i18n-glossary"],

          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
                { name: "Addison Phillips", mailto: "addisonI18N@gmail.com", company: "Invited Expert", w3cid: 33573 }
                ],

          // authors, add as many as you like. 
          //authors:  [
          //    { name: "Your Name", url: "http://example.org/",
          //      company: "Your Company", companyURL: "http://example.com/" },
          //],
          
          // name of the WG
          wg:           "Internationalization Working Group",
          wgURI:        "https://www.w3.org/International/core/",
          wgPublicList: "www-international",
          
		  bugTracker: { new: "https://github.com/w3c/string-search/issues", open: "https://github.com/w3c/string-search/issues" } ,
		otherLinks: [
			{
			key: "Github",
			data: [
				{
			  	value: "repository",
			  	href: "https://github.com/w3c/string-search/"
		 		}
				]
			}
			],

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/32113/status",
		  

		  localBiblio: {
		"UTS18": {
		    title: "Unicode Technical Standard #18: Unicode Regular Expressions",
			href: "https://unicode.org/reports/tr18/",
			authors: [ "Mark Davis", "Andy Heninger" ]
		},
		
		"Encoding": {
			title: "Encoding",
			href: "https://www.w3.org/TR/encoding/",
			authors: [ "Anne van Kesteren", "Joshua Bell", "Addison Phillips" ]
		},
		
		"ISO10646": {
			title: "Information Technology - Universal Multiple- Octet Coded CharacterSet (UCS) - Part 1: Architecture and Basic Multilingual Plane",
			authors: [ "ISO/IEC10646-1:1993" ],
			note: "The current specification also takes into consideration the first five amendments to ISO/IEC 10646-1:1993. Useful roadmaps (http://www.egt.ie/standards/iso10646/ucs-roadmap.html) show which scripts sit at which numeric ranges."
		},
		
		"UTS10": {
			title: "Unicode Technical Standard #10: Unicode Collation Algorithm",
			href: "https://www.unicode.org/reports/tr10/",
			authors: [ "Mark Davis", "Ken Whistler", "Markus Scherer" ]
		},
		
		"UAX11": {
		    title: "Unicode Standard Annex #11: East Asian Width",
		    href: "https://www.unicode.org/reports/tr11/",
		    authors: [ "Ken Lunde 小林劍" ]
		},
		
		"UAX29": {
			title: "Unicode Standard Annex #29: Unicode Text Segmentation",
			href: "https://www.unicode.org/reports/tr29/",
			authors: [ "Mark Davis" ]
		},
		
		"UTS39": {
		    title: "Unicode Technical Standard #39: Unicode Security Mechanisms",
		    href: "https://www.unicode.org/reports/tr39/",
		    authors: [ "Mark Davis", "Michel Suignard" ]
		},
		
		"UTR36": {
			title: "Unicode Technical Report #36: Unicode Security Considerations",
			href: "https://www.unicode.org/reports/tr36/",
			authors: [ "Mark Davis", "Michel Suignard" ]
		},
		
		"UTR50": {
		    title: "Unicode Technical Report #50: Unicode Vertical Text Layout",
		    href: "https://www.unicode.org/reports/tr50/",
		    authors: [ "Koji Ishii 石井宏治", "Laurențiu Iancu" ]
		},
		
		"Nicol": {
			title: "The Multilingual World Wide Web, Chapter 2: The WWW As A Multilingual Application",
			href: "http://www.mind-to-mind.com/i18n/multilingual-www.html",
			authors: [ "Gavin Nicol" ]
		}
		
	}
		  
      };
	  

</script> </head>
  <body>
    <section id="abstract">
      <p>This document describes string searching operations on the Web in order to allow greater interoperability. String searching refers to natural language string matching such as the "find" command in a Web browser. This document builds upon the concepts found in <cite>Character Model for the World Wide Web 1.0: Fundamentals </cite>[[CHARMOD]] and <cite>Character Model for the World Wide Web 1.0: String Matching</cite> [[CHARMOD-NORM]] to provide authors of specifications, software developers, and content developers the information they need to describe and implement search features suitable for global audiences. </p>
    </section>
    <section id="sotd">
      <div class="note">
        <p data-lang="en" style="font-weight: bold; font-size: 120%">Sending comments on this document</p>
        <p data-lang="en">If you wish to make comments regarding this document, please raise them as <a href="https://github.com/w3c/string-search/issues" style="font-size: 120%;">github issues</a> against the latest <a href="https://w3c.github.io/string-search"> editor's copy</a>. Only send comments by email if you are unable to raise issues on github (see links below). All comments are welcome.</p>
        
        <p data-lang="en">To make it easier to track comments, please raise separate issues or emails for each comment, and point to the section you are commenting on using a URL.</p>
      </div>
    </section>
    <section id="intro">
      <h2>Introduction</h2>
      <section id="goals">
        <h3>Goals and Scope</h3>
        <p>This document describes the problems, requirements, and considerations for specification or implementations of string searching operations. A common example of string searching is the "find" command in a Web browser, but there are many other forms of searching that a specification might wish to define. </p>
        
        <p class="note">This document builds on <cite>Character Model for the World Wide Web: Fundamentals</cite> [[CHARMOD]] and <cite>Character Model for the Word Wide Web: String Matching</cite> [[CHARMOD-NORM]]. Understanding the concepts in those documents are important to being able to understand and apply this document successfully.</p>
        
        <p>The main target audience of this specification is W3C specification developers who need to define some form of search or find algorithm: the goal is to provide a stable reference to the concepts, terms, and requirements needed.</p>
        
        <p>The concepts described in this document provide authors of specifications, software developers, and content developers with a common reference for consistent, interoperable text searching on the World Wide Web. Working together, these three groups can build a globally accessible Web.</p>
        
        <p>This document contains best practices and requirements for other specifications, as well as recommendations for implementations and content authors. These best practices for specifications (and others) can also be found in the Internationalization Working Group's document <cite>[[INTERNATIONAL-SPECS]]</cite>, which is intended to serve as a general reference for all Internationalization best practices in W3C specifications.</p>
        
      </section>
        
      <section id="conventions">
	  <h3>Document Conventions</h3>
	
        <p>In this document [[RFC2119]] keywords in uppercase italics have their usual meaning. We also use these stylistic conventions:</p>

        <p class="definition-example"><strong>Definitions</strong> appear with a different background color and decoration like this.</p>
        <p class="advisement"><strong>Best practices</strong> appear with a different background color and decoration like this.</p>
        <p class="issue-example" id="issue-example"><strong>Issues</strong>, gaps, and recommendations for future work appear with a different background color and decoration like this.</p>

      </section>
      
      <section id="terminology">
        <h3>Terminology</h3>
        <p>This section contains terminology specific to this document.</p>
        
        <p>Much of the terminology needed to understand this document is provided by the <cite>Internationalization Glossary</cite> [[I18N-GLOSSARY]]. Some terms are also defined by [[CHARMOD-NORM]] and can be found in the <a href="https://www.w3.org/TR/charmod-norm/#terminology">Terminology and Notation</a> section of that document.</p>
        
        <p><a>Unicode</a>, also known as the <a>Universal Character Set</a>, allows Web documents to be authored in any of the world's writing systems, scripts, or languages, on any computing platforms and then to be exchanged, read, and searched by the Web's users around the world. The first few chapters of the <cite>Unicode Standard</cite> [[Unicode]] provide useful background reading. Also see the <cite>Unicode Collation Algorithm</cite> [[UTS10]], which contains a chapter on searching.</p>
         
        <p class="definition"><dfn>Corpus</dfn> The natural language text contained by a document or set of documents which the user would like to search.</p>
        <p class="definition"><dfn>Segmentation</dfn> The process of breaking natural language text up into distinct words and phrases. This often includes operations such as "named entity recognition" (such as recognizing that the three word sequence <strong>Dr. Jonas Salk</strong> is a person's name).</p>
        <p class="definition"><dfn data-lt="stemming|lemmatization">Stemming</dfn> A process or operation that reduces words to their "stem" or root. For example, the words <strong>runs</strong>, <strong>ran</strong>, and <strong>running</strong> all share the stem <strong>run</strong>. This some sometimes called (more formally) <em>lemmatization</em> and the stem is sometimes called the <em>lemma</em>.</p>
        
        <p class="definition"><dfn data-lt="full text search|full-text search|full text searching">Full-Text Search</dfn> refers to searches that process the entire contents of the textual document or set of documents. Full-text queries perform linguistic searches against text data in full-text indexes by operating on words and phrases based on the rules of a particular language such as English or Japanese. Full-text queries can include simple words and phrases or multiple forms of a word or phrase.</p>
        <p>Frequently this means that a <a>full-text search</a> employs indexes and natural language processing. When you are using a search engine, you are using a form of full text search. Full text search often breaks natural language text into words or phrases (this is called <a>segmentation</a>) and may apply complex processing to get at the semantic "root" values of words (this is called <a>stemming</a>). These processes are sensitive to language, context, and many other aspects of textual variation.</p>
        
        </section>
      </section>
 
    </section>
    <section id="searching">
      <h2>String Searching in Natural Language Content</h2>
      
      <div class="issue">
		  <p>String searching is widely implemented in browsers and other user agents, but has not historically been well documented. Various W3C working groups have attempted to provide such documentation in the past. The most recent effort produced <a href="https://github.com/w3c/i18n-activity/issues?q=is%3Aissue++label%3As%3Afindtext+label%3Aneeds-resolution">these issues</a>.</p>
		  
		  <!-- here are the direct links
		  <dl>
			  <li><a href="https://github.com/w3c/i18n-activity/issues/111">111</a></li>
			  <li><a href="https://github.com/w3c/i18n-activity/issues/110">110</a></li>
			  <li><a href="https://github.com/w3c/i18n-activity/issues/109">109</a></li>
			  <li><a href="https://github.com/w3c/i18n-activity/issues/108">108</a></li>
			  <li><a href="https://github.com/w3c/i18n-activity/issues/107">107</a></li>
			  <li><a href="https://github.com/w3c/i18n-activity/issues/106">106</a></li>
			  <li><a href="https://github.com/w3c/i18n-activity/issues/105">105</a></li>
			  <li><a href="https://github.com/w3c/i18n-activity/issues/104">104</a></li>
			  <li><a href="https://github.com/w3c/i18n-activity/issues/103">103</a></li>
		  </dl>
		  -->
      </div>
      
      <p>Users of the Web often want to search documents for particular words or phrases within the natural language text of a given document. This is different from the sorts of programmatic matching needed by formal languages (such as markup languages such as [[HTML]]; style sheets [[CSS21]]; or data formats such as [[TURTLE]] or [[JSON-LD]]), and which are described by our document [[CHARMOD-NORM]]. </p>
      
      <p>There are different types of string searching. 
    
      <p>One limited form of full-text search&mdash;and the topic of this document&mdash;is sub-string matching. One familiar form of sub-string matching is the "find" feature of your browser. A sub-string match searches the body ("<a>corpus</a>") of a document with the user's input, seeking a match.</p>
      
      <p>Find operations can have different options or implementation details, such as the addition or removal of case sensitivity, or whether the feature supports different aspects of a regular expression language or "wildcards".</p>
      
      <p>One way that sub-string matching usually differs from other types of <a>full-text search</a> is that, while it may use algorithms in an attempt to suppress or ignore textual variations, it usually does not produce matches that contain additional or unspecified character sequences, words, or phrases.</p>
      
      <p>Quite often, the user's input does not use a sequence of <a>code points</a> identical to that in the text being searched. This can happen for a variety of reasons. Sometimes it is because the text varies in ways the user cannot predict. In other cases it is because the user's keyboard or input method does not provide ready access to the textual variations needed&mdash;or because the user cannot be bothered to input the text accurately. In this section, we examine various common cases known to us.</p>
      
	  <section id="otherEquivalences">
         <h3>Additional Types of Equivalence</h3>
         
         <p>When searching text, the concept of "grapheme boundaries" and "user-perceived characters" can be important. See Section 3 of <cite>Character Model for the World Wide Web: Fundamentals</cite> [[CHARMOD]] for a description. For example, if the user has entered a capital "A" into a search box, should the software find the character &#xc0; (<code class="uname" translate="no">U+00C0 LATIN CAPITAL LETTER A WITH ACCENT GRAVE</code>)? What about the character "A" followed by <code class="uname" translate="no">U+0300 COMBINING ACCENT GRAVE</code>? What about writing systems, such as Devanagari, which use combining marks to suppress or express certain vowels?</p>
         
         <p>In order to describe or implement sub-string matching, it is necessary to understand the types of textual variation that users expect the search feature to pay attention to (or ignore) and the types of features that the implementation will need to consider when building the searching algorithm.</p>
         
         <p>The <cite>Character Model for the World-Wide Web: String Matching</cite> [[CHARMOD-NORM]] describes several textual equivalences which also apply to sub-string matching. These include <a href="https://www.w3.org/TR/charmod-norm/#definitionCaseFolding">case folding</a> and <a href="https://www.w3.org/TR/charmod-norm/#unicodeNormalization">different Unicode normalization forms</a>.

         <p>There are other types of equivalence that are interesting when performing sub-string matching. Some forms of equivalence, such as those mentioned above, are based on character properties assigned by Unicode or due to the mapping of legacy character encodings to the Unicode character set. Other "interesting equivalences" go outside of those defined by Unicode. Some of these potential "text normalizations" are application, natural language, or domain specific and should not be overlooked by specifications or implementations.</p>

         
        <section id="caseVariation">
			<h4>Case Folding</h4>
			
		    <p>A user might expect a term entered in lowercase to match uppercase equivalents (and perhaps vice-versa). Most sub-string matching feature, such as the browser "find" command, offer a user-selectable option for matching the case of the input to that of the text.</p>
		    
		    <p>For a survey of case folding, see the discussion <a href="https://www.w3.org/TR/charmod-norm/#definitionCaseFolding">here</a> in [[CHARMOD-NORM]].</p>
		
        </section>
		 
     <section id="unicodeNormalization">
		 <h4>Unicode Normalization and character equivalence</h4>

        <p>Unicode defines canonical and compatibility relationships between characters which can impact user perceptions of string searching. For a detailed discussion of Unicode Normalization forms see Section 2.2 of [[CHARMOD-NORM]] as well as the definitions found in <cite>Unicode Normalization Forms</cite> [[UAX15]].</p>
        
        <aside class="example">
        <p>For example, consider the letter "K". The characters with a normalization including <code>U+004B LATIN CAPITAL LETTER K</code> include the following, many of which might be expected to match a letter "K" in a sub-string search request by a user because they appear to contain a logical "letter K":</p>
        <ul>
          <li>&#x0136; <code>U+0136 LATIN CAPITAL LETTER K WITH CEDILLA</code>
          <li>&#x01E8; <code>U+01E8 LATIN CAPITAL LETTER K WITH CARON</code>
          <li>&#x1D37; <code>U+1D37 MODIFIER LETTER CAPITAL K</code>
          <li>&#x1E30; <code>U+1E30 LATIN CAPITAL LETTER K WITH ACUTE</code>
          <li>&#x1E32; <code>U+1E32 LATIN CAPITAL LETTER K WITH DOT BELOW</code>
          <li>&#x1E34; <code>U+1E34 LATIN CAPITAL LETTER K WITH LINE BELOW</code>
          <li>&#x212A; <code>U+212A KELVIN SIGN</code>
          <li>&#x24C0; <code>U+24C0 CIRCLED LATIN CAPITAL LETTER K</code>
          <li>&#x3385; <code>U+3385 SQUARE KB</code>
          <li>&#x33CD; <code>U+33CD SQUARE KK</code>
          <li>&#x33CE; <code>U+33CE SQUARE KM CAPITAL</code>
          <li>&#xFF2B; <code>U+FF2B FULLWIDTH LATIN CAPITAL LETTER K</code>
          <li>&#x1D40A; <code>U+1D40A MATHEMATICAL BOLD CAPITAL K</code>
          <li>&#x1D43E; <code>U+1D43E MATHEMATICAL ITALIC CAPITAL K</code>
          <li>&#x1D472; <code>U+1D472 MATHEMATICAL BOLD ITALIC CAPITAL K</code>
          <li>&#x1D4A6; <code>U+1D4A6 MATHEMATICAL SCRIPT CAPITAL K</code>
          <li>&#x1D4DA; <code>U+1D4DA MATHEMATICAL BOLD SCRIPT CAPITAL K</code>
          <li>&#x1D50E; <code>U+1D50E MATHEMATICAL FRAKTUR CAPITAL K</code>
          <li>&#x1D542; <code>U+1D542 MATHEMATICAL DOUBLE-STRUCK CAPITAL K</code>
          <li>&#x1D576; <code>U+1D576 MATHEMATICAL BOLD FRAKTUR CAPITAL K</code>
          <li>&#x1D5AA; <code>U+1D5AA MATHEMATICAL SANS-SERIF CAPITAL K</code>
          <li>&#x1D5DE; <code>U+1D5DE MATHEMATICAL SANS-SERIF BOLD CAPITAL K</code>
          <li>&#x1D612; <code>U+1D612 MATHEMATICAL SANS-SERIF ITALIC CAPITAL K</code>
          <li>&#x1D646; <code>U+1D646 MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL K</code>
          <li>&#x1D67A; <code>U+1D67A MATHEMATICAL MONOSPACE CAPITAL K</code>
          <li>&#x1F11A; <code>U+1F11A PARENTHESIZED LATIN CAPITAL LETTER K</code>
          <li>&#x1F13A; <code>U+1F13A SQUARED LATIN CAPITAL LETTER K</code>
        </ul>
        </aside>
        
        <p>In many complex scripts it is possible to encode letters or vowel-signs in more than one way, but the alternatives are canonically equivalent.</p>    
      </section>  

	  <section id="scriptEquiv">
			<h4>Script Equivalence</h4>
			
		    <p>Some languages are written in more than one script. A user searching a document might type in text in one script, but wish to find equivalent text in both scripts.</p>
		    
		    <aside class="example">
				<p>Japanese uses two syllabic scripts, <code>hiragana</code> and <code>katakana</code>. These scripts encode the same phonemes; thus the user might expect that typing in a search term in <em>hiragana</em> would find the exact same word spelled out in <em>katakana</em>.</p>
				<pre>&#x306B;&#x307B;&#x3093;&#x3054; // hiragana
&#x30CB;&#x30DB;&#x30F3;&#x30B4; // katakana
				</pre>
		    </aside>
		 </section>
		 
		 
		 <section id="eastAsianWidthEquiv">
			 <h4>East Asian Width</h4>
			 
			 <p>Some compatibility characters were encoded into Unicode to account for single- or multibyte representation in <a>legacy character encodings</a> or for compatibility with certain layout behaviors in East Asian languages. For example, the full-width characters in the range <code>U+FF01</code> through <code>U+FF5E</code> or the half-width katakana characters.</p>
			 
			 <aside class="example">
				 <p>Here is an example of East Asian width variation:</p>
				 <pre>&#x30CB;&#x30DB;&#x30F3;&#x30B4; // full-width katakana
&#xFF86;&#xFF8E;&#xFF9D;&#xFF7A;&#xFF9E; // half-width katakana
				 </pre>
			 </aside>
		 </section>

         <section id="digitShaping">
			 <h4>Digit Shaping</h4>
		 
		 <p>Many scripts have their own digit characters for the numbers from 0 to 9. In some Web applications, the familiar ASCII digits are replaced for display purposes with the local digit shapes. In other cases, the text actually might contain the Unicode characters for the local digits. Users attempting to search a document might expect that typing one form of digit will find the eqivalent digits.</p>
		 
		 <aside class="example" title="Examples of digit shapes in four scripts">
		   <p>Here are some selected examples of different digit shapes, from zero to nine, in four scripts. Many scripts have equivalent sets of digits with distinct shapes.</p>
		 
           <table style="position:center">
            <thead>
			<tr>
			    <th rowspan=2 style="vertical-align:top; width:30%;">Script</th>
			    <th colspan=10 style="text-align:center">Digits</th>
			</tr>
			<tr>
			    <th class="exampleChar">0</th>
			    <th class="exampleChar">1</th>
			    <th class="exampleChar">2</th>
			    <th class="exampleChar">3</th>
			    <th class="exampleChar">4</th>
			    <th class="exampleChar">5</th>
			    <th class="exampleChar">6</th>
			    <th class="exampleChar">7</th>
			    <th class="exampleChar">8</th>
			    <th class="exampleChar">9</th>
			</tr>
                   </thead>
		   <tbody>
                       <tr>
		   	    <td>Latin</td>
			    <td class="exampleChar">0</td>
			    <td class="exampleChar">1</td>
			    <td class="exampleChar">2</td>
			    <td class="exampleChar">3</td>
			    <td class="exampleChar">4</td>
			    <td class="exampleChar">5</td>
			    <td class="exampleChar">6</td>
			    <td class="exampleChar">7</td>
			    <td class="exampleChar">8</td>
			    <td class="exampleChar">9</td>
			</tr>
                       <tr>
		   	    <td>Gujurati</td>
			    <td class="exampleChar">&#x0ae6;</td>
			    <td class="exampleChar">&#x0ae7;</td>
			    <td class="exampleChar">&#x0ae8;</td>
			    <td class="exampleChar">&#x0ae9;</td>
			    <td class="exampleChar">&#x0aea;</td>
			    <td class="exampleChar">&#x0aeb;</td>
			    <td class="exampleChar">&#x0aec;</td>
			    <td class="exampleChar">&#x0aed;</td>
			    <td class="exampleChar">&#x0aee;</td>
			    <td class="exampleChar">&#x0aef;</td>
			</tr>
                       <tr>
		   	    <td>Thai</td>
			    <td class="exampleChar">&#x0e50;</td>
			    <td class="exampleChar">&#x0e51;</td>
			    <td class="exampleChar">&#x0e52;</td>
			    <td class="exampleChar">&#x0e53;</td>
			    <td class="exampleChar">&#x0e54;</td>
			    <td class="exampleChar">&#x0e55;</td>
			    <td class="exampleChar">&#x0e56;</td>
			    <td class="exampleChar">&#x0e57;</td>
			    <td class="exampleChar">&#x0e58;</td>
			    <td class="exampleChar">&#x0e59;</td>
			</tr>
			<tr>
				<td>Arabic</td>
				<td class="exampleChar">&#x0660;</td>
				<td class="exampleChar">&#x0661;</td>
				<td class="exampleChar">&#x0662;</td>
				<td class="exampleChar">&#x0663;</td>
				<td class="exampleChar">&#x0664;</td>
				<td class="exampleChar">&#x0665;</td>
				<td class="exampleChar">&#x0666;</td>
				<td class="exampleChar">&#x0667;</td>
				<td class="exampleChar">&#x0668;</td>
				<td class="exampleChar">&#x0669;</td>
			</tr>
	           </tbody>

	         </table>
		 </aside>
		 </section>
         
        <section id="orthoVariation">
			 <h4>Orthographic or Dialectical Variation</h4>
			 
			 <p>Some languages have different orthographic traditions that vary by region or dialect or allow different spellings of the same word. Searches and spell-checking may need to know about these variations.</p>
			 
			 <p class="example">US English and UK English have different spelling traditions, which manifest in different ways. For example, <strong>color</strong> versus <strong>colour</strong> or exchanging the letters <em>s</em> and <em>z</em> as in <em>internationali<span style="font-size:125%">Z</span>ation</em> vs. <em>internationali<span style="font-size:125%">S</span>ation</em>. A few words have even more divergent spellings, such as <strong>jail</strong> vs. <strong>gaol</strong>.</p>
			 
			 <p>The spelling variants for US vs UK English are mostly standardised, however sometimes the spelling is down to personal preferences (or sometimes lack of knowledge).  For example, the US English word 'through' can be spelled 'thru'.</p>
			 
			<section id="south-asian-scripts">
			<h4>South Asian (Indic script) languages</h4>

             <p>Indic script languages have many instances of this kind of problem.  Sometimes these are spelling errors, but in other cases multiple spellings are acceptable.</p>

             <p>For example, the Bengali language (language tag <code class="kw" translate="no">bn</code>) is notorious for having a wide range of spelling variations permitted by the language: nearly 80% of Bengali words have at least two spellings. Many words have 3, 4, or more variations&mdash;with at least one word having 16 different <em>valid</em> spellings.</p>

             <aside class="example">
                 <p>One example is the word which transliterates to the Latin script as <em lang="bn-Latn">rani</em>, but which users may spell with different letters and vowel marks. In modern Bengali <span class="codepoint" translate="no"><bdi lang="bn">&#x09A3;</bdi> [<a href="/scripts/bengali/block#char09A3"><span class="uname">U+09A3 BENGALI LETTER NNA</span></a>]</span> and <span class="codepoint" translate="no"><bdi lang="bn">&#x09A8;</bdi> [<a href="/scripts/bengali/block#char09A8"><span class="uname">U+09A8 BENGALI LETTER NA</span></a>]</span> are pronounced /n/, and <span class="codepoint" translate="no"><bdi lang="bn">&#x09BF;</bdi> [<a href="/scripts/bengali/block#char09BF"><span class="uname">U+09BF BENGALI VOWEL SIGN I </span></a>]</span> and <span class="codepoint" translate="no"><bdi lang="bn">&#x09C0;</bdi> [<a href="/scripts/bengali/block#char09C0"><span class="uname">U+09C0 BENGALI VOWEL SIGN II </span></a>]</span> are both pronounced /i/.  Therefore different users might choose any of the following alternative <a>code point</a> sequences for the same word:</p>
                 <table>
					 <tbody>
						 <tr>
							 <td><span class="exampleChar" translate="no"><bdi lang="bn">&#x000A;&#x09B0;&#x09BE;&#x09A3;&#x09BF;</bdi></span></td>
							 <td><span class="uname">U+09B0 BENGALI LETTER RA</span> + <span class="uname">U+09BE BENGALI VOWEL SIGN AA</span> + <span class="uname">U+09A3 BENGALI LETTER NNA</span> + <span class="uname">U+09BF BENGALI VOWEL SIGN I</span></td>
						 </tr>
						 <tr>
							 <td><span class="exampleChar" translate="no"><bdi lang="bn">&#x09B0;&#x09BE;&#x09A8;&#x09BF;</bdi></span></td>
							 <td><span class="uname">U+09B0 BENGALI LETTER RA</span> + <span class="uname">U+09BE BENGALI VOWEL SIGN AA</span> + <span class="uname">U+09A8 BENGALI LETTER NA</span> + <span class="uname">U+09BF BENGALI VOWEL SIGN I</span></td>
						 </tr>
						 <tr>
							 <td><span class="exampleChar" translate="no"><bdi lang="bn">&#x000A;&#x09B0;&#x09BE;&#x09A3;&#x09C0;</bdi></span></td>
							 <td><span class="uname">U+09B0 BENGALI LETTER RA</span> + <span class="uname">U+09BE BENGALI VOWEL SIGN AA</span> + <span class="uname">U+09A3 BENGALI LETTER NNA</span> + <span class="uname">U+09C0 BENGALI VOWEL SIGN II</span></td>
						 </tr>
						 <tr>
							 <td><span class="exampleChar" translate="no"><bdi lang="bn">&#x09B0;&#x09BE;&#x09A8;&#x09C0;</bdi></span></td>
							 <td><span class="uname">U+09B0 BENGALI LETTER RA</span> + <span class="uname">U+09BE BENGALI VOWEL SIGN AA</span> + <span class="uname">U+09A8 BENGALI LETTER NA</span> + <span class="uname">U+09C0 BENGALI VOWEL SIGN II</span></td>
						 </tr>
					 </tbody>
                 </table>
                
             </aside>

             <p>Other Indic scripts provide alternative mechanisms for representing particular sounds, and in most cases either representation is considered equally valid. The most common instance of this involves representation of syllable-final nasals.</p>

             <p>For example, the <samp translate="no">/n/</samp> sound in the word <em>Hindi</em> in Hindi can be written using either a nasal consonant (a half glyph form when part of a conjunct), or using a diacritic. Both of the following are possible valid spellings and are pronounced identically:</p>

             <aside class="example">
				 <table>
					 <tbody>
						 <tr>
							 <td class="exampleChar">&#x0939;&#x093F;&#x0928;&#x094D;&#x0926;&#x0940;</td>
							 <td>U+0939 U+093F U+0928 U+094D U+0926 U+0940</td>
							 <td>With <span class="" translate="no"><bdi lang="hi">&#x94d;</bdi></span> [<span class="uname">U+094D DEVANAGARI SIGN VIRAMA</span>] to suppress the inherent vowel</td>
						 </tr>
						 <tr>
							 <td class="exampleChar"> &#x0939;&#x093F;&#x0902;&#x0926;&#x0940;</td>
							 <td>U+0939 U+093F U+0902 U+0926 U+0940</td>
							 <td>With <span class="" translate="no"><bdi lang="hi">&#x902;</bdi></span> [<span class="uname">U+0902 DEVANAGARI SIGN ANUSWARA</span>] representing the nasal consonent</td>
						 </tr>
					 </tbody>
				 </table>
             </aside>

             <p>In an additional twist to this story, two diacritics with different code points could be used here.  In our previous example we used <span class="codepoint" translate="no"><bdi lang="hi">&#x0902;</bdi> [<span class="uname">U+0902 DEVANAGARI SIGN ANUSVARA </span>]</span> to represent the nasal sound because the accompanying vowel-sign rises above the hanging baseline.  If the vowel-sign was one that didn't rise above the hanging baseline, we would normally use <span class="codepoint" translate="no"><bdi lang="hi">&#x0901;</bdi> [<span class="uname">U+0901 DEVANAGARI SIGN CANDRABINDU </span>]</span> instead.  The function of both of these diacritics is the same, but their code points are different.</p>
             
             <p>The alternative use of letter or diacritic for syllable-final nasals is common to many other Indian languages. In addition to Devanagari (used to write languages such as Hindi (language tag <code translate="no">hi</code> or Marathi (language tag <code translate="no">mr</code>), scripts such as Malayalam, Odia, Gujarati, and others provide similar spelling options. </p>
			
			<table>
			<thead>
				<tr>
					<th>Language</th>
					<th>Example</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td rowspan=2>Malayalam (<kbd>ml</kbd>)</td>
					<td class="exampleChar" lang="ml">&#x0D26;&#x0D41;&#x0D03;&#x0D16;&#x0D02;</td>
				</tr>
				<tr>
					<td class="exampleChar" lang="ml">&#x0D26;&#x0D41;&#x0D16;&#x0D02;</td>
				</tr>
				<tr>
					<td rowspan=2>Odia (<kbd>or</kbd>)</td>
					<td class="exampleChar">&#x0B28;&#x0B3F;</td>
				</tr>
				<tr>
					<td class="exampleChar">&#x0B33;&#x0B15;&#x0B02;&#x0B20;</td>
				</tr>
				<tr>
					<td rowspan=2>Marathi (<kbd>mr</kbd>)</td>
					<td class="exampleChar" lang="mr">&#x0905;&#x0928;&#x0924;&#x0917;&#x0930;&#x0924;</td>
				</tr>
				<tr>
					<td class="exampleChar" lang="mr">&#x0905;&#x0902;&#x0924;&#x0917;&#x0930;&#x0924;</td>
				</tr>
				<tr>
					<td rowspan="2">Gujarati (<kbd>gu</kbd>)</td>
					<td class="exampleChar">&#x0A9A;&#x0A82;&#x0AAA;&#x0AB2;</td>
				</tr>
				<tr>
					<td class="exampleChar">&#x0A9A;&#x0AAE;&#x0AAA;&#x0AB2;</td>
				</tr>
			</tbody>
        </table>
        

        </section>

         </section>
         
         <section id="whitespaceNormalization">
			 <h4>Whitespace Normalization</h4>
			 
			 <p>Some languages use whitespace to separate words, sentences, or paragraphs while others do not. When performing sub-string matching, different forms of whitespace found in [[Unicode]] must be normalized so that the match succeeds.</p>
	     </section>
	     


	    
	    <section id="accents">
			<h4>Accents and diacritic marks</h4>
	    
	        <p>Users will sometimes vary their input when dealing with letters that contain accents or diacritic marks when entering search terms in scripts (such as the Latin script) that use various diacritics, even though the text they are searching includes the additional marks. This is particularly true on mobile keyboards, where input of these characters can require additional effort. In these cases, users generally expect the search operation to be more "promiscuous" to make up for their failure to make the additional effort needed.</p>
	        
        <aside class="example">
		   <p>Users in languages such as French sometimes omit entering accents when inputting search terms because it is more work to enter the correct character, even though this affects the meaning. For example, they might type <code>cote</code> and might expect to find the variations (which have different meanings) like <code>côte</code> or <code>côté</code>, etc. This is "misspelling".</p>
        </aside>
	    
	    <aside class="example">
	       <p>German uses several letters that have an <em>umlaut</em> accent, such as <span class="codepoint" translate="no"><bdi lang="de">&#x00F6;</bdi> [<span class="uname">U+00F6 LATIN SMALL LETTER O WITH DIERISIS</span>]</span> or <span class="codepoint" translate="no"><bdi lang="de">&#x00FC;</bdi> [<span class="uname">U+00FC LATIN SMALL LETTER U WITH DIERISIS</span>]</span>. Users sometimes will enter these accents when searching, but sometimes they replace the umlauts with the letter <code>e</code>. For example, instead of entering <code>Dürst</code> they might enter <code>Duerst</code>. Either spelling is recognizable and has the same meaning. The umlauts are probably "better" than the <code>e</code> spelling, but German speakers are not confused by the difference.</p>
        
           <p class="note">Other languages use these same characters for a different purpose than German does. The formal name of the "umlaut" diacritic in Unicode is <em>diaeresis</em>, which means approximately "break" or "pause". Languages such as French, Spanish, and English occasionally use the diaeresis to indicate the need to pronounce a specific letter, such as the word "<span lang="es">ambigüedad</span>" in Spanish or a name like "Zoë" in English.</p>
        </aside>
        
        <p>This effect might vary depending on context as well. For example, a person using a physical keyboard may have direct access to accented letters, while a virtual or on-screen keyboard may require extra effort to access and select the same letters.</p>
        </section>
        
        <section id="optional-characters">
			<h4>Optional characters</h4>
	
		    <p>In some orthographies it is necessary to match strings with different numbers of characters.</p>

            <p>A prime example of this involves vowel diacritics in <a>abjads</a>.  For example, some languages that use the Arabic and Hebrew scripts do not require (but optionally allow) the user to input short vowels. (For some other languages in these scripts, the inclusion of the short vowels is not optional.) The presence or absence of vowels in the text being input or searched might impede a match if the user doesn't enter or know to enter them.</p>
		    
		<aside class="example">
		   <p>Arabic, Persian, and Urdu users generally do not enter short vowels&mdash;but some texts do include them. Searching is affected by this, but meaning generally is not. A generalized description of this might be "optional to encode" sequences.</p>
		</aside>
		</section>
		
		<section id="visually-identical-non-canonical">
			
			<h4>Visually identical text that is not canonically equivalent</h4>
		
		    <p>Some languages which use the Arabic script have <a>graphemes</a> which can be encoded in more than one way. In some cases, these variations are handled by <a href="#unicodeNormalization">Unicode Normalization</a>, but in other cases they are not considered equivalent by Unicode, even if they appear visually to be identical. Sometimes these variations are considered to be valid spelling variations. In other cases they are the result of user's mistaken perception.</p>
		    
		    <p>For example, a number languages, such as the Kashmiri language (language tag <kbd>ks</kbd>), are written in the Arabic script but are unrelated to the Arabic language. These languages thus sometimes require character sequences to represent sounds not present in Arabic. A significant problem for some of these languages is that the specially-encoded character sequences can be visually similar (or identical) to other character sequences and users may experience difficulty entering or knowing how to enter the correct sequence, such as when inputting a term to search for:</p>
				
				<table>
					<thead>
						<tr>
						   <th>Description</th>
						   <th colspan=4 style="text-align:center">Examples</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><strong>Canonically equivalent alternatives</strong><br/>(differences resolved by Unicode Normalization)</td>
							<td class="exampleChar">&#x625;</td>
							<td><code class="uname" translate="no">U+0625 ARABIC LETTER ALEF WITH HAMZA BELOW</code></td>
							<td class="exampleChar">&#x627;&#x655;</td>
							<td><code class="uname" translate="no">U+0627 ARABIC LETTER ALEF</code> + <code class="uname" translate="no">U+0655 ARABIC HAMZA BELOW</code></td>

						</tr>
						<tr>
							<td><strong>Not canonically equivalent</strong><br/>(differences that <em>remain</em> after Unicode Normalization) Many of these are linked to user perception of whether the vowel is part of the base letter (<em lang="ar-Latn" translate="no">ijam</em>) vs. separable (<em lang="ar-Latn" translate="no">tashkil</em>)</td>
							<td class="exampleChar">&#x6ce;</td>
							<td><code class="uname" translate="no">U+06CE ARABIC LETTER YEH WITH SMALL V</code></td>
							<td class="exampleChar">&#x6cc;&#x65a;</td>
							<td><code class="uname" translate="no">U+06CC ARABIC LETTER FARSI YEH</code> + <code class="uname" translate="no">U+065A ARABIC VOWEL SIGN SMALL V ABOVE</code></td>
						</tr>
						<tr>
							<td><strong>Confusables or spelling errors</strong><br/>these can be common in certain kinds of text due to gaps in keyboard support or due to a similarity in appearance</td>
							<td class="exampleChar">&#x626;</td>
							<td><code class="uname" translate="no">U+0626 ARABIC LETTER YEH WITH HAMZA ABOVE</code></td>
							<td class="exampleChar">&#x6cc;&#x654;</td>
							<td><code class="uname" translate="no">U+06CC ARABIC LETTER FARSI YEH</code> + <code class="uname" translate="no">U+0654 ARABIC HAMZA ABOVE</code></td>
						</tr>
					</tbody>
				</table>
				
			<p>Users may also create visually identical (or very similar) graphemes from sequences of characters that are deprecated or unexpected by the Unicode Standard. For example, in some fonts it is possible to create something that looks like the independent vowel /au/ using the (normal) <span class="codepoint" translate="no"><bdi lang="ta">&#x0B94;</bdi> [<a href="/scripts/tamil/block#char0B94"><span class="uname">U+0B94 TAMIL LETTER AU</span></a>]</span>, or by typing two inappropriate individual letters, <span class="codepoint" translate="no"><bdi lang="ta">&#x0B92;&#x0BB3;</bdi> [<a href="/scripts/tamil/block#char0B92"><span class="uname">U+0B92 TAMIL LETTER O</span></a> + <a href="/scripts/tamil/block#char0BB3"><span class="uname">U+0BB3 TAMIL LETTER LLA</span></a>]</span>.  The latter should by avoided by users, but applications will need to decide whether or not to match such aberrations if they appear in the text.</p>
			
			<p>For more information, see Richard Ishida's doc <a href="https://r12a.github.io/scripts/arabic/ks.html#encoding">here</a>.</p>

		</section>
		    


        <section id="otherSouthAsian_DO_NOT_LINK_TO_ME">
			<h4>Other South Asian issues</h4>
        <p>Other South Asian languages have their own variations. Here are some examples:</p>
        
        <p class=issue>TBD.</p>
        
       
      </section>
      </section><!-- end of "additional types of equivalence" -->
	     

      <section id="searchingConsiderations">
        <h2>Considerations for Searching</h2>
        
        <p class="issue">This section was identified as a new area needing document as part of the overall rearchitecting of the document. The text here is incomplete and needs further development. Contributions from the community are invited.</p>
        
		<p>Implementers often need to provide simple "find text" algorithms and specifications often try to define APIs to support these needs. Find operations on text generate different user expectations and thus have different requirements from the need for absolute identity matching needed by document formats and protocols. It is important to note that domain-specific requirements may impose additional restrictions or alter the considerations presented here.</p>
		
		<p class="advisement">Increasing input effort from the user SHOULD be mirrored by more selective matching.</p>
		
		<p>When the user expends more effort on the input&mdash;by using the shift key to produce uppercase or by entering a letter with diacritics instead of just the base letter&mdash;they might expect their search results to match (only) their more-specific input.</p>
		
		<aside class="example">
		    <p>Consider a document containing these strings: "re-resume", "RE-RESUME", "re-r&#xe9;sum&#xe9;", and "RE-R&#xc9;SUM&#xc9;".</p>
        
            <p>In the table below, the user's input (on the left) might be considered a match for the above items as follows:</p>
            <table class="data">
              <tbody>
                <tr>
                  <th scope="col">User Input</th>
                  <th scope="col">Matched Strings</th>
                </tr>
                <tr>
                  <td>e (lowercase 'e')</td>
                  <td>"re-resume", "RE-RESUME", "re-r&#xe9;sum&#xe9;", and "RE-R&#xC9;SUM&#xc9;"</td>
                </tr>
                <tr>
                  <td>E (uppercase 'E')</td>
                  <td>"RE-RESUME" and "RE-R&#xc9;SUM&#xc9;"</td>
                </tr>
                <tr>
                  <td>&#xe9; (lowercase 'e' with acute accent)</td>
                  <td>"re-r&#xe9;sum&#xe9;" and "RE-R&#xc9;SUM&#xc9;"</td>
                </tr>
                <tr>
                  <td>&#xc9; (uppercase 'E' with acute accent)</td>
                  <td>"RE-R&#xc9;SUM&#xc9;"</td>
                </tr>
              </tbody>
            </table>
            </aside>
		

      
      <section id="SearchOptions">
      <h3>Types of Search Option</h3>
      <p>When creating a string search API or algorithm, the following textual options might be useful to users:</p>
      <ul>
         <li>Case-sensitive vs. case-insensitive</li>
         <li>Kana folding</li>
         <li>Unicode normalization form</li>
         <li>etc.</li>
      </ul>
      </section>
    </section>

    <section>
      <h2 id="Acknowledgements" class="informative">Acknowledgements</h2>
      <p>The W3C Internationalization Working Group and Interest Group, as well as others, provided many comments and suggestions. The Working Group would like to thank: all of the contributors to the Character Model series of documents over the many years of their development. </p>
    </section>
  </body>
</html>
